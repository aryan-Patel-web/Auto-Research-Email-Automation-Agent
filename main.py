import os
import pandas as pd
import smtplib
from email.message import EmailMessage
from flask import Flask, request, render_template
from dotenv import load_dotenv
from typing import List, Optional

from langchain_groq import ChatGroq
from langchain_community.utilities import WikipediaAPIWrapper, ArxivAPIWrapper
from langchain_community.tools import WikipediaQueryRun, ArxivQueryRun
from langchain_astradb import AstraDBVectorStore
from langchain_huggingface import HuggingFaceEmbeddings

from langgraph.graph import StateGraph, END
from pydantic import BaseModel  # ‚úÖ FIXED

# ========== Load Environment Variables ==========
load_dotenv()

groq_api_key = os.getenv("GROK_API_KEY")
hf_token = os.getenv("HF_TOKEN")
astra_db_token = os.getenv("ASTRA_DB_APPLICATION_TOKEN")
astra_db_id = os.getenv("ASTRA_DB_ID")
astra_db_keyspace = os.getenv("ASTRA_DB_KEYSPACE")
email_user = os.getenv("EMAIL_HOST_USER")
email_pass = os.getenv("EMAIL_HOST_PASS")

assert all([groq_api_key, hf_token, astra_db_token, astra_db_id, astra_db_keyspace, email_user, email_pass]), "‚ùå Missing .env variables!"

# ========== LLM Setup ==========
llm = ChatGroq(groq_api_key=groq_api_key, model="llama3-70b-8192")

# ========== Embeddings + Vector Store Setup ==========
embedding_model = HuggingFaceEmbeddings(
    model_name="sentence-transformers/all-MiniLM-L6-v2",  # ‚úÖ USE model_name instead of model
)

vectorstore = AstraDBVectorStore(
    embedding=embedding_model,
    collection_name="research_summaries",
    token=astra_db_token,
   api_endpoint = f"https://{astra_db_id}-us-east-2.apps.astra.datastax.com"

    namespace=astra_db_keyspace
)

# ========== Research Tools ==========
wiki_tool = WikipediaQueryRun(
    api_wrapper=WikipediaAPIWrapper(top_k_results=1, doc_content_chars_max=2000),
    return_direct=True
)
arxiv_tool = ArxivQueryRun(api_wrapper=ArxivAPIWrapper(), return_direct=True)

# ========== Email & Summary ==========

def summarize_text(text):
    prompt = f"Summarize the following content in structured point-wise format with headings:\n\n{text}"
    result = llm.invoke(prompt)
    return result.content if hasattr(result, "content") else str(result)

def send_email(summary, subject="üß† AI Summary", to="test@example.com"):
    msg = EmailMessage()
    msg["Subject"] = subject
    msg["From"] = email_user
    msg["To"] = to
    msg.set_content(f"""
üìò AI Research Summary

{summary}

üîó Generated by your AI Agent
""")
    with smtplib.SMTP_SSL("smtp.gmail.com", 465) as smtp:
        smtp.login(email_user, email_pass)
        smtp.send_message(msg)
    return f"‚úÖ Email sent to {to}"

# ========== LangGraph Steps ==========
class ResearchState(BaseModel):
    input: str
    wiki: Optional[str] = None
    arxiv: Optional[str] = None
    summary: Optional[str] = None
    email: Optional[str] = None
    email_list: Optional[List[str]] = None

def research(state: ResearchState) -> dict:
    query = state.input
    wiki = wiki_tool.run(query)
    arxiv = arxiv_tool.run(query)
    return {"wiki": wiki, "arxiv": arxiv}

def summarize_step(state: ResearchState) -> dict:
    combined = f"{state.wiki}\n\n{state.arxiv}"
    summary = summarize_text(combined)
    vectorstore.add_texts([summary], metadatas=[{"query": state.input}])
    return {"summary": summary}

def email_step(state: ResearchState) -> dict:
    summary = state.summary or ""
    email_list = state.email_list or []
    for email in email_list:
        send_email(summary, to=email)
    return {"summary": summary, "email": "‚úÖ Summary sent to all recipients."}

# ========== Build LangGraph ==========
workflow = StateGraph(ResearchState)
workflow.add_node("research_node", research)
workflow.add_node("summarize_node", summarize_step)
workflow.add_node("send_email_node", email_step)
workflow.set_entry_point("research_node")
workflow.add_edge("research_node", "summarize_node")
workflow.add_edge("summarize_node", "send_email_node")
workflow.add_edge("send_email_node", END)

graph_app = workflow.compile()

# ========== Flask App ==========
app = Flask(__name__)

@app.route('/')
def index():
    return render_template("index.html")

@app.route('/run', methods=['POST'])
def run_query():
    query = request.form.get("query", "").strip()
    try:
        df = pd.read_csv("emails.csv")
        email_list = df["email"].dropna().tolist()
    except:
        return render_template("result.html", summary="‚ùå Couldn't load emails.csv", email="")

    if not query:
        return render_template("result.html", summary="‚ùå No query entered", email="")

    try:
        result = graph_app.invoke({
            "input": query,
            "email_list": email_list
        })
        return render_template("result.html", summary=result["summary"], email=result["email"])
    except Exception as e:
        return render_template("result.html", summary="‚ùå Internal Error", email=str(e))

if __name__ == "__main__":
    app.run(debug=True)
