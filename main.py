from flask import Flask, request, render_template
import pandas as pd
import os
import smtplib
from email.message import EmailMessage
from typing import List, Optional
from langgraph.graph import StateGraph, END
# from langchain_core.pydantic_v1 import BaseModel
from langchain_groq import ChatGroq
from langchain_community.utilities import WikipediaAPIWrapper, ArxivAPIWrapper
from langchain_community.tools import WikipediaQueryRun, ArxivQueryRun
from pydantic import BaseModel



# ---------- LLM and Tools Setup ----------
groq_api_key = os.environ.get("GROK_API_KEY")
llm = ChatGroq(groq_api_key=groq_api_key, model="llama3-70b-8192")

wiki_wrapper = WikipediaAPIWrapper(top_k_results=1, doc_content_chars_max=2000)
wiki_tool = WikipediaQueryRun(api_wrapper=wiki_wrapper, return_direct=True)
arxiv_wrapper = ArxivAPIWrapper()
arxiv_tool = ArxivQueryRun(api_wrapper=arxiv_wrapper, return_direct=True)



# ---------- Email + Summary ----------
def summarize_text(text, query=None):
    prompt = f"""You are an expert research summarizer.

Topic: {query}

Summarize the following content in a well-structured, point-wise format with clear headings and subheadings. Use bullets or numbering if needed. Focus only on information relevant to the topic:

{text}
"""
    result = llm.invoke(prompt)
    return result.content if hasattr(result, "content") else str(result)



def send_email(summary, subject="üß† AI Summary Report", to="aryanpatel77462@gmail.com", query=""):
    formatted_summary = f"""
Hi {to},

üìå ----Your Search Topic------:  
>>>>>{query}>>>>>>>>>

---

üß† **AI-Generated Research Summary**

Here is a structured summary based on the topic above:

{summary}

---

üì¨ **Note**:  
This is an automated summary generated by an AI Agent built by Aryan Patel (IIIT).  
If you'd like more topics summarized, just submit a new query via the AI Research Assistant app.

Warm regards,  
**AI Research Assistant Bot**  
[Built with LangGraph + Groq + Python]  
"""
    
    msg = EmailMessage()
    msg["Subject"] = subject
    msg["From"] = "aryan9140782212@gmail.com"
    msg["To"] = to
    msg.set_content(formatted_summary)

    with smtplib.SMTP_SSL("smtp.gmail.com", 465) as smtp:
        smtp.login("aryan9140782212@gmail.com", "kgfc ylkw doax ljqh")
        smtp.send_message(msg)

    return f"‚úÖ Email sent to {to}"



# ---------- Graph State + Steps ----------
class ResearchState(BaseModel):
    input: str
    wiki: Optional[str] = None
    arxiv: Optional[str] = None
    summary: Optional[str] = None
    email: Optional[str] = None
    email_list: Optional[List[str]] = None

def research(state: ResearchState) -> dict:
    query = state.input
    wiki = wiki_tool.run(query)
    arxiv = arxiv_tool.run(query)
    return {"wiki": wiki, "arxiv": arxiv}

def summarize_step(state: ResearchState) -> dict:
    combined = f"{state.wiki}\n\n{state.arxiv}"
    summary = summarize_text(combined)
    return {"summary": str(summary)}

def email_step(state: ResearchState) -> dict:
    summary = state.summary or ""
    query = state.input  # ‚úÖ Get the real user question
    email_list = state.email_list or []

    for to in email_list:
        send_email(summary, query=query, to=to)

    return {"summary": summary, "email": "‚úÖ Summary sent to all recipients."}



# ---------- Graph Build ----------
workflow = StateGraph(ResearchState)
workflow.add_node("research_node", research)
workflow.add_node("summarize_node", summarize_step)
workflow.add_node("send_email_node", email_step)

workflow.set_entry_point("research_node")

workflow.add_edge("research_node", "summarize_node")
workflow.add_edge("summarize_node", "send_email_node")
workflow.add_edge("send_email_node", END)

app_graph = workflow.compile()




# ---------- Flask App ----------



app = Flask(__name__)


@app.route('/')
def home():
    return render_template("index.html")

@app.route('/run', methods=['POST'])
def run_summary():
    query = request.form.get('query', '').strip()

    df = pd.read_csv("emails.csv")
    email_list = df["email"].dropna().tolist()

    if not query:
        return render_template("result.html", summary="‚ùå No query provided.", email="")

    if not email_list:
        return render_template("result.html", summary="‚ùå No emails found in emails.csv", email="")

    try:
        result = app_graph.invoke({"input": query, "email_list": email_list})
        return render_template("result.html", summary=result["summary"], email=result["email"])
    except Exception as e:
        return render_template("result.html", summary="‚ùå Error occurred", email=str(e))



if __name__ == "__main__":
    app.run(debug=True)  